{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>     Stateful &amp; programmablemock server   </p>"},{"location":"#introduction","title":"Introduction","text":"<p>Drosse is a stateful and programmable mock server written in javascript.</p> <p>Based on h3, Drosse uses loki to store your mock data in memory so you can modify them in your <code>POST</code>, <code>PUT</code>, <code>PATCH</code> and <code>DELETE</code> requests.</p> <p>It comes out of the box with all the features you need to completely simulate a backend API, making it the best companion for any frontend developer \ud83e\udd13</p>"},{"location":"#features","title":"Features","text":"<ul> <li> <p> Tight to your project  Your mocks and your mock-server are part of your project. You can run as many drosse instances as you want simultaneously. </p> </li> <li> <p> Easy configuration  Configuring drosse is as simple as writing its port number in a <code>.drosserc.js</code> file and writing route definitions in a <code>routes.json</code> file. </p> </li> <li> <p> Cascading configs  Routes are defined as a JSON tree of sub-paths - plugins (throttle, proxy, ...) are inherited by child routes. </p> </li> <li> <p> Static mocks  Write mocks directly in the <code>routes.json</code> file (inline mode) or in JSON files (static mode). </p> </li> <li> <p> Dynamic mocks  Build dynamic responses in javascript and access to the persisted data api, request and response objects and the NodeJS environment. </p> </li> <li> <p> Assets handling  Serve multimedia files with patterns and wild cards for easy fallback. </p> </li> <li> <p> Dynamic URL params  Match any route/endpoint pattern with dynamic parameters (e.g. <code>/api/users/:id</code>). </p> </li> <li> <p> Data persistence  Work with stateful and interactive mocks thanks to the in-memory JSON database accessible via an easy-to-use API. </p> </li> <li> <p> Throttling  Delay response time of your routes, even the proxied ones. </p> </li> <li> <p> Proxying  Super-flexible proxy mechanism with inheritance and overwriting of sub-routes (with different proxy or local route). </p> </li> <li> <p> Middlewares  Extend Drosse with custom express middlewares to fulfill your use cases (user session, websocket, jwt, ...). </p> </li> <li> <p> Templates  Uuse response templates to avoid repeating yourself. </p> </li> <li> <p> Scraping  Scrape proxied endpoints and save the content to Drosse's database or static files. </p> </li> <li> <p> Extensible REPL CLI  Build custom commands and execute them at runtime =&gt; simulate interaction with 3rp-party services. </p> </li> </ul>"},{"location":"#examples","title":"Examples","text":"<p>Find example code in the examples folder.</p>"},{"location":"#contact-support","title":"Contact &amp; Support","text":"<ul> <li>Create a GitHub issue for bug reports, feature requests, or questions</li> <li>Add a \u2b50\ufe0f star on GitHub or \u2615\ufe0f buy us a coffe to support the project!</li> </ul>"},{"location":"#credits-license","title":"Credits &amp; License","text":"<p>Drosse is crafted by Jota and licensed under the MIT license.</p>"},{"location":"assets/","title":"Assets","text":"<p>You can use the <code>assets</code> property in the <code>DROSSE</code> object to tell a path to serve only static contents. Let's check the following example:</p> <pre><code>{\n  \"content\": {\n    \"DROSSE\": {\n      \"assets\": true\n    },\n    \"imgs\": {\n      \"background_*.jpg\": {\n        \"DROSSE\": {\n          \"assets\": \"content/images/background_mocked.png\"\n        }\n      }\n    }\n  }\n}\n</code></pre> <p>In this example, all calls done to <code>/content</code> will be done statically on the <code>assets/content</code> directory. For example, if you call <code>http://localhost:8000/content/fonts/myfont.woff2</code>, Drosse will look up for a file in <code>[your mocks root]/assets/content/fonts/myfont.woff2</code> and serve it statically.</p> <p>The example reveals another feature: you can rewrite the path through the <code>assets</code> property. If you call <code>http://localhost:8000/content/imgs/background_whatever.jpg</code>, Drosse will statically serve the <code>[your mocks root]/assets/content/imgs/background_whatever.jpg</code> file.</p> <p>Info</p> <p>You can redefine this <code>assets</code> folder name in your <code>.drosserc.js</code> file (see Configuration).</p>"},{"location":"commands/","title":"CLI commands","text":"<p>Drosse, once started, is a REPL console where you can type commands. It uses Vorpal.</p> <p>This feature is still under active development, but you can already create your own commands and register them in the <code>.drosserc.js</code>.</p>"},{"location":"configuration/","title":"Configuration","text":""},{"location":"configuration/#the-drossercjs-file","title":"The .drosserc.js file","text":"<p>This file holds your mock server general configuration. It's optional as all its keys have default values. It must simply export a configuration object.</p> <p>Here is a typical example of what it could contain.</p> .drosserc.ts<pre><code>import { defineDrosseServer } from '@jota-one/drosse'\n\nexport default defineDrosseServer({\n  name: 'My mocks app',\n  port: 8000,\n})\n</code></pre>"},{"location":"configuration/#configuration-reference","title":"Configuration reference","text":"Key Default value Description <code>name</code> - The name of your app. Mostly used to recognize it in your console or in drosse UI. <code>port</code> <code>8000</code> The port on which your mock server will run.If not specified in <code>.drosserc.js</code> and already in use, Drosse will use the next available port if finds (8001, 8002, etc.) <code>baseUrl</code> - The base URL (ex. http://my.domain.com) for the routes <code>basePath</code> - A prefix (ex. /api/v2) that will be added to each route path <code>routesFile</code> <code>routes</code> Name of the routes definition file. <code>collectionsPath</code> <code>collections</code> Relative path to the loki collections directory from your mocks directory. <code>shallowCollections</code> <code>[]</code> List of collections that should be recreated/overriden on each server restart. <code>assetsPath</code> <code>assets</code> Relative path to the assets directory from your mocks directory. <code>servicesPath</code> <code>services</code> Relative path to the services directory from your mocks directory. <code>staticPath</code> <code>static</code> Relative path to the static files directory from your mocks directory. <code>scraperServicesPath</code> <code>scrapers</code> Relative path to the scraper services files directory from your mocks directory. <code>scrapedPath</code> <code>scraped</code> Relative path to the scraped files directory from your mocks directory. <code>uploadPath</code> <code>uploadedFiles</code> Relative path to the uploaded files directory from your mocks directory. These files are deleted when the db is deleted. <code>database</code> <code>mocks.db</code> Name of your loki database dump file. <code>dbAdapter</code> <code>LokiFsAdapter</code> IO adapter to use for database persistence. <code>middlewares</code> <code>['morgan']</code> List of global middlewares. Drosse provides 2 built-in middlewares, 1 being added by default. The second one is 'open-cors'. <code>templates</code> <code>{}</code> Templates to be used in <code>routes.json</code>. See Templates documentation. <code>extendServer</code> - Used to set custom instructions to the server application. Must be a function with the following signature: <code>function ({ server, app, db }) {}</code>. <code>server</code> being the node http.Server instance, <code>app</code> the h3 instance and <code>db</code> the drosse db api. <code>onHttpUpgrade</code> <code>null</code> A function that initiates a websocket connection. This is happening once during HTTP protocol upgrade handshake. Must be a function with the following signature: <code>function (request, socket, head) { ... }</code>. <code>commands</code> - Used to extend Drosse CLI with custom commands. Must be a function with the following signature: function (vorpal, drosse) { ... }. See the CLI commands documentation."},{"location":"customize-response/","title":"Customize response","text":""},{"location":"customize-response/#throttle","title":"Throttle","text":"<p>A must have feature if you want to detect your race condition and test your lovely loading animations. You can throttle any endpoint by adding the <code>throttle</code> configuration object into it. Just like this:</p> <pre><code>{\n  \"api\": {\n    \"users\": {\n      \"DROSSE\": {\n        \"get\": {\n          \"throttle\": {\n            \"min\": 1000,\n            \"max\": 2000\n          }\n        },\n        \"post\": {}\n      },\n      \":id\": {\n        \"DROSSE\": {\n          \"get\": {}\n        }\n      }\n    }\n  }\n}\n</code></pre> <p>In the example above, the route <code>GET /api/users</code> will be throttled between 1 and 2 seconds (randomly chosen in the boundaries).</p> <p>Tip</p> <p>Of course, you can put your throttle at any level of your routes tree and it will be inherited in all the sub routes that don't have their own <code>throttle</code> configuration.</p> <pre><code>{\n  \"api\": {\n    \"DROSSE\": {\n      \"throttle\": {\n        \"min\": 5000,\n        \"max\": 10000\n      }\n    },\n    \"users\": {\n      \"DROSSE\": {\n        \"get\": {\n          \"throttle\": {\n            \"min\": 1000,\n            \"max\": 2000\n          }\n        },\n        \"post\": {}\n      },\n      \":id\": {\n        \"DROSSE\": {\n          \"get\": {}\n        }\n      }\n    }\n  }\n}\n</code></pre> <p>Here all the routes under <code>/api</code> will be throttled between 5 and 10 seconds, except the <code>GET /api/users</code> that keeps its own 1-2 seconds throttling.</p>"},{"location":"customize-response/#proxy","title":"Proxy","text":"<p>In Drosse, proxies let you escape from your mock-server for a while. How does it work ?</p> <p>Anywhere in your routes <code>tree</code>, you can define a proxy (inside the <code>DROSSE</code> object, like always). All the routes matching the path where your proxy is defined, but NOT matching a subsequent route will be proxied to... your proxy. Okay this sentence is really f***-up. Let's have a look to the <code>routes.json</code>.</p> <pre><code>{\n  \"api\": {\n    \"users\": {\n      \"DROSSE\": {\n        \"get\": {\n          \"throttle\": {\n            \"min\": 1000,\n            \"max\": 2000\n          }\n        },\n        \"post\": {}\n      },\n      \":id\": {\n        \"DROSSE\": {\n          \"get\": {}\n        }\n      }\n    },\n    \"countries\": {\n      \"DROSSE\": {\n        \"proxy\": \"https://restcountries.com/v3.1\"\n      }\n    }\n  }\n}\n</code></pre> <p>In the above example, any request made on <code>http://localhost:8000/api/countries</code> will be done instead on <code>https://restcountries.com/v3.1</code>. The subsequent path will be applied as well.</p> <p>So <code>http://localhost:8000/api/countries/name/indonesia</code> will be proxied to <code>https://restcountries.com/v3.1/name/indonesia</code> and return the expected result.</p> <p>Of course you can still define subroutes in a proxied path. They will take precedence on the proxy. Let's change our <code>countries</code> block like this:</p> <pre><code>    \"countries\": {\n      \"DROSSE\": {\n        \"proxy\": \"https://restcountries.com/v3.1\"\n      },\n      \"name\": {\n        \"switzerland\": {\n          \"DROSSE\": {\n            \"get\": {\n              \"body\": {\n                \"name\": \"Switzerland\",\n                \"description\": \"Best country in the World!\"\n              }\n            }\n          }\n        }\n      }\n    }\n</code></pre> <p>If we call <code>http://localhost:8000/api/countries/name/switzerland</code>, Drosse will not proxy the request as there is a fully qualified path in our routes definition. We will then get the response defined just above and not a proxied response.</p>"},{"location":"customize-response/#advanced-proxy-settings","title":"Advanced proxy settings","text":"<p>If you need advanced proxy settings, you can use an object instead of a string, like this:</p> <pre><code>    \"countries\": {\n      \"DROSSE\": {\n        \"proxy\": {\n          \"target\": \"https://localhost:8081/api\",\n          \"secure\": false,\n          \"ws\": true\n        }\n      }\n</code></pre> <p>As we use node-http-proxy in the background, please refer to its documentation for all available options.</p>"},{"location":"customize-response/#templates","title":"Templates","text":"<p>A small yet very handsome feature. Templates help you to DRY your mocked endpoints. In Drosse, a template is a simple function that takes a content and transforms it to something else. Let's take an example:</p> <pre><code>{\n  \"api\": {\n    \"DROSSE\": {\n      \"template\": \"response\"\n    },\n    \"products\": {\n      \"v1\": {\n        \"DROSSE\": {\n          \"template\": \"responseV1\"\n        }\n      }\n    },\n    \"other\": {},\n    \"routes\": {}\n  }\n}\n</code></pre> <p>When passing a <code>template</code> to a node, you tell Drosse to apply this template to all endpoint results from this node path and all subnodes. Except if you redefine another template. In that case it will take precedence. In our example, any call to <code>/api</code>, <code>/api/products</code>, <code>/api/other</code> or <code>/api/routes</code> will have their response passed to the <code>response</code> template. But a call to <code>/api/products/v1</code> will have its response passed to <code>responseV1</code> template.</p> <p>To use a template, you need to create a JS file, store it somewhere in your <code>[mocks root]</code> directory and reference it in your <code>.drosserc.js</code> file. Here is an example of <code>.drosserc.js</code> file with our 2 templates registered:</p> <pre><code>// .drosserc.js\nimport { defineDrosseServer } from '@jota-one/drosse'\nimport response from './templates/response'\nimport responseV1 from './templates/responseV1'\n\nexport default defineDrosseServer({\n  name: 'My awesome app',\n  port: 8004,\n  templates: { response, responseV1 },\n})\n</code></pre> <p>Here we stored the templates in a <code>templates</code> directory, but you can load them from wherever you prefer. You simply need to register each template function in a <code>templates</code> property.</p> <p>Here is how the <code>response</code> and <code>responseV1</code> template could look like:</p> <pre><code>// response.js\nexport default response =&gt; {\n  return {\n    version: 'v2',\n    data: response,\n  }\n}\n</code></pre> <pre><code>// responseV1.js\nexport default response =&gt; {\n  return {\n    version: 'v1',\n    ...response,\n  }\n}\n</code></pre> <p>You can also use these templates to perform intermediate transformations in your services (see Dynamic mocks) as they are also simple JS functions...</p> <p>Note</p> <p>You need to register your templates in the <code>.drosserc.js</code> file only if you want to use them in the <code>routes.json</code> file.</p>"},{"location":"db-api/","title":"Db API","text":"<p>Drosse leverages LokiJS power to allow stateful interactive mocking. But don't worry, no need for database configuration or any complicated stuffs. Basically, LokiJS is a nosql document database (a bit like mongo, but way simpler).</p> <p>When you start your mock server for the first time, Drosse will create a database and store it in a <code>mocks.json</code> file in your <code>[mocks root]</code> directory. Yes! You've read it, it's a simple JSON file. You can open it in your IDE and see the content of your database. But don't modify it manually, it will probably break the database. To be precise, LokiJS is a in-memory database and it will simply dump its content every 4 seconds in the <code>mocks.json</code> file.</p> <p> How do I update it, then ?</p> <p>LokiJS is collections-based. You can consider each collection as an array of objects, each object being a document.</p> <p>To provide some contents to your database, you need to create a <code>collections</code> directory in your <code>[mocks root]</code> directory. In this directory you will define your collections. A collection can be either:</p> <ul> <li>A directory that contains JSON files. These files must contain a JSON object (not an array).</li> <li>A JSON files that must contain an array of objects.</li> </ul> <p>In the end it's the same. Drosse will process either the directory or the big JSON file and insert it as a new collection full of documents in your database.</p> <p>Note</p> <p>You can redefine the <code>mocks.json</code> database file and the <code>collections</code> directory name in your <code>.drosserc.js</code> file (see Configuration).</p> <p>By default, on each startup Drosse will check the <code>collections</code> directory and see if the collection already exists in the database. If not, it will import it. If the collection already exists, Drosse won't import it again; even if you added new files in the collection directory.</p> <p>If you want a fresh database, simply delete the <code>mocks.json</code> file and restart Drosse.</p> <p>Tip</p> <p>You can also type directly <code>db drop</code> in the Drosse CLI to achieve the same goal.</p> <p> That's a bit hard! Is there a smoother way?</p> <p>You ask it, we provide.</p> <p>You can define a <code>shallowCollections</code> key in your <code>.drosserc.js</code> file. It must contain an array with collection names. All the collections listed in this array will be recreated from the JSON files in the <code>collections</code> directory on each Drosse startup.</p>"},{"location":"db-api/#identify-your-documents","title":"Identify your documents","text":"<p>One more thing. To make Drosse aware of how you identify each of your document, you should provide in each document a <code>DROSSE</code> property which contains an <code>ids</code> property, which itself contains a list of what you consider the document identifiers.</p> <p>It can be very useful to have different identifiers for your documents. As the identifiers don't have to be unique, it's not an issue. Don't forget that Drosse is a mock server. You aim to mock a real system that lives somewhere out there. And in the real world, it happens often that the same entity is retrieved through different ways. Imagine a Project entity. It could be retrieved by its unique ID, but maybe also by a customer unique code or whatever else.</p> <p>The real backend has probably different methods to fetch the project accordingly. But here we want to be fast and we don't care about all that. So we can store all the potential identifiers of a document in our <code>DROSSE.ids</code> array. It will look like this:</p> <p><pre><code>{\n  \"id\": 1980,\n  \"name\": \"Construction of a skyscraper\",\n  \"customer\": {\n    \"id\": 888,\n    \"name\": \"ACME corp\",\n    \"projectCode\": \"SKYSCRAPER-999\"\n  },\n  \"budget\": 98000000,\n  \"DROSSE\": {\n    \"ids\": [1980, \"SKYSCRAPER-999\"]\n  }\n}\n</code></pre> Like this, it will be easier to find our document and we won't have to ask ourselves which identifier was sent to our service.</p>"},{"location":"db-api/#reference-documents","title":"Reference documents","text":"<p>In the above example we have a customer inside a project. But what if we want to list all the customers in our app ? We could duplicate the customer informations into a <code>customers</code> collection, but that would mean that the customer's informations displayed in the project document are duplicated. Not good to maintain our mocks...</p> <p>Here come reference documents to the rescue!</p> <p>Assuming you have a <code>customers</code> collection with this customer document in it.</p> <pre><code>{\n  \"id\": 888,\n  \"name\": \"ACME corp\",\n  \"address\": {\n    \"street\": \"Undefined or null 1\",\n    \"zip\": \"00001\",\n    \"town\": \"North Pole City\"\n  },\n  \"activity\": \"Secretely conquer the world by not being evil... at first.\",\n  \"DROSSE\": {\n    \"ids\": [888]\n  }\n}\n</code></pre> <p>You can redefine your project like this:</p> <pre><code>{\n  \"id\": 1980,\n  \"name\": \"Construction of a skyscraper\",\n  \"customer\": {\n    \"collection\": \"customers\",\n    \"id\": 888,\n    \"projectCode\": \"SKYSCRAPER-999\"\n  },\n  \"budget\": 98000000,\n  \"DROSSE\": {\n    \"ids\": [1980, \"SKYSCRAPER-999\"]\n  }\n}\n</code></pre> <p>The company name is not duplicated anymore.</p> <p>When you've fetched the project document, you can easily query the linked customer by calling the <code>db.get.byRef()</code> method and pass it the <code>project.customer</code> object. Drosse will automatically understand the pattern \"collection - id\" and return the corresponding customer document. You can then overwrite <code>project.customer</code> with this result.</p>"},{"location":"db-api/#api","title":"API","text":"<p>Once your documents are stored in the database, here is how you can query them or even insert new documents programmatically. As you've maybe already read above in the Dynamic mocks section, when you define a service function, it takes an object as argument and this object contains a <code>db</code> property. This <code>db</code> property exposes the whole Drosse DB API. Let's have a look to it in detail.</p>"},{"location":"db-api/#list","title":"list","text":""},{"location":"db-api/#all","title":"all","text":"<p><code>db.list.all(collection, cleanFields)</code></p> <p>List all documents in a collection.</p> Argument Required Type Description collection yes String The collection name cleanFields no Array A list of properties you want to exclude from each returned document <p>Returns an Array of documents.</p>"},{"location":"db-api/#byid","title":"byId","text":"<p><code>db.list.byId(collection, id, cleanFields)</code></p> <p>List all documents in a collection that have the provided identifier.</p> Argument Required Type Description collection yes String The collection name id yes Mixed A document identifier cleanFields no Array A list of properties you want to exclude from each returned document <p>Returns an Array of documents.</p>"},{"location":"db-api/#byfields","title":"byFields","text":"<p><code>db.list.byFields(collection, fields, value, cleanFields)</code></p> <p>List all documents in a collection having at least one of the provided fields that contains the provided value.</p> Argument Required Type Description collection yes String The collection name fields yes String[] A list of fields value yes Mixed A value to test for. Should be a string or number cleanFields no Array A list of properties you want to exclude from each returned document <p>Returns an Array of documents.</p>"},{"location":"db-api/#byfield","title":"byField","text":"<p><code>b.list.byField(collection, field, value, cleanFields)</code></p> <p>List all documents in a collection having the provided field that contains the provided value.</p> Argument Required Type Description collection yes String The collection name field yes String A field value yes Mixed A value to test for. Should be a string or number cleanFields no Array A list of properties you want to exclude from each returned document <p>Returns an Array of documents.</p>"},{"location":"db-api/#find","title":"find","text":"<p><code>db.list.find(collection, query, cleanFields)</code></p> <p>List all documents in a collection matching the provided query.</p> Argument Required Type Description collection yes String The collection name query yes Object A lokiJS query object cleanFields no Array A list of properties you want to exclude from each returned document <p>Returns an Array of documents.</p>"},{"location":"db-api/#where","title":"where","text":"<p><code>db.list.where(collection, searchFn, cleanFields)</code></p> <p>List all documents in a collection for which the searchFn callback returns a truthy value</p> Argument Required Type Description collection yes String The collection name searchFn yes Function A function that will be called for each document and take the document in argument. cleanFields no Array A list of properties you want to exclude from each returned document <p>Returns an Array of documents.</p>"},{"location":"db-api/#get","title":"get","text":""},{"location":"db-api/#byid_1","title":"byId","text":"<p><code>db.get.byId(collection, id, cleanFields)</code></p> <p>Find first document in a collection that have the provided identifier.</p> Argument Required Type Description collection yes String The collection name id yes Mixed A document identifier cleanFields no Array A list of properties you want to exclude from each returned document <p>Returns a document.</p>"},{"location":"db-api/#byfields_1","title":"byFields","text":"<p><code>db.get.byFields(collection, fields, value, cleanFields)</code></p> <p>Find first document in a collection having at least one of the provided fields that contains the provided value.</p> Argument Required Type Description collection yes String The collection name fields yes String[] A list of fields value yes Mixed A value to test for. Should be a string or number cleanFields no Array A list of properties you want to exclude from each returned document <p>Returns a document.</p>"},{"location":"db-api/#byfield_1","title":"byField","text":"<p><code>db.get.byField(collection, field, value, cleanFields)</code></p> <p>Find first document in a collection having the provided field that contains the provided value.</p> Argument Required Type Description collection yes String The collection name field yes String A field value yes Mixed A value to test for. Should be a string or number cleanFields no Array A list of properties you want to exclude from each returned document <p>Returns a document.</p>"},{"location":"db-api/#find_1","title":"find","text":"<p><code>db.get.find(collection, query, cleanFields)</code></p> <p>Find first document in a collection matching the provided query.</p> Argument Required Type Description collection yes String The collection name query yes Object A lokiJS query object cleanFields no Array A list of properties you want to exclude from each returned document <p>Returns a document.</p>"},{"location":"db-api/#where_1","title":"where","text":"<p><code>db.get.where(collection, searchFn, cleanFields)</code></p> <p>Find first document in a collection for which the searchFn callback returns a truthy value</p> Argument Required Type Description collection yes String The collection name searchFn yes Function A function that will be called for each document and take the document in argument. cleanFields no Array A list of properties you want to exclude from each returned document <p>Returns a document.</p>"},{"location":"db-api/#byref","title":"byRef","text":"<p><code>db.get.byRef(refObj, dynamicId, cleanFields)</code></p> <p>Find first document in a collection matching the provided query.</p> Argument Required Type Description refObj yes Object An object that contains a <code>collection</code> property and an <code>id</code> property. See Reference documents dynamicId no Mixed A document identifier cleanFields no Array A list of properties you want to exclude from each returned document <p>Returns a document.</p> <pre><code>const getDetailedProject = projectId =&gt; {\n  const myProject = db.get.byId('projects', projectId)\n  myProject.customer = db.get.byRef(myProject.customer)\n  return myProject\n}\n\nconst detailedProject = getDetailedProject(1980)\n</code></pre>"},{"location":"db-api/#query","title":"query","text":""},{"location":"db-api/#getmapid","title":"getMapId","text":"<p><code>db.query.getMapId(collection, fieldname, firstOnly)</code></p> <p>Generate a hash to link a specific document field value to the document ids (or first id)</p> Argument Required Type Description collection yes String The collection name fieldname yes String A field firstOnly no Boolean If <code>true</code>, will consider only the first <code>id</code> found in the <code>DROSSE.ids</code> array. <p>Returns a correspondance hash with the chosen field value as key and the corresponding id as value.</p> <p>Warning</p> <p>Be aware that if the chosen <code>fieldname</code> hasn't unique values for each document in collection, the later documents will overwrite the formers.</p>"},{"location":"db-api/#chain","title":"chain","text":"<p><code>db.query.chain(collection)</code></p> <p>Exposes the LokiJS chain method (see LokiJS documentation for more details)</p> Argument Required Type Description collection yes String The collection name <p>Returns a LokiJS ResultSet</p>"},{"location":"db-api/#clean","title":"clean","text":"<p><code>db.query.clean([...fields])</code></p> <p>Creates a cleaning function that will remove all listed fields from the passed object</p> Argument Required Type Description ...fields no ...String Any number of fieldnames <p>Returns a function that takes a javascript Object as unique argument</p> <p>Note</p> <p>Even if no fields are passed, the function will be configured to remove the <code>reseserved words</code> from Drosse and Loki, aka: <code>$loki</code>, <code>meta</code> and <code>DROSSE</code>.</p> <p>Info</p> <p>This function is used in all other methods to clean up the results and merges the optional <code>cleanFields</code> with the <code>reserved words</code>.</p>"},{"location":"db-api/#insert","title":"insert","text":"<p><code>db.insert(collection, ids, payload)</code></p> <p>Inserts a document in a collection</p> Argument Required Type Description collection yes String The collection name ids yes Array An array of identifiers for your new document (will be stored in <code>DROSSE.ids</code>) payload yes Object The document <p>Returns the inserted document</p>"},{"location":"db-api/#update","title":"update","text":""},{"location":"db-api/#byid_2","title":"byId","text":"<p><code>db.update.byId(collection, id, newValue)</code></p> <p>Updates a document in a collection</p> Argument Required Type Description collection yes String The collection name id yes Mixed One of the document identifiers (from <code>DROSSE.ids</code>) newValue yes Object A hash with keys being of type <code>field.subfield.subsubfield</code> (lodash.set is used to apply the changes) <p>Returns nothing</p>"},{"location":"db-api/#subitem-append","title":"subItem-append","text":"<p><code>db.update.subItem.append(collection, id, subPath, payload)</code></p> <p>Insert (append) a new item in some of the identified document subItems list</p> Argument Required Type Description collection yes String The collection name id yes Mixed One of the document identifiers (from <code>DROSSE.ids</code>) subPath yes String A string of type <code>field.subfield.subsubfield</code> pointing to the field to alter payload yes Object The sub item to insert <p>Returns nothing</p>"},{"location":"db-api/#subitem-prepend","title":"subItem-prepend","text":"<p><code>db.update.subItem.prepend(collection, id, subPath, payload)</code></p> <p>Insert (prepend) a new item in some of the identified document subItems list</p> Argument Required Type Description collection yes String The collection name id yes Mixed One of the document identifiers (from <code>DROSSE.ids</code>) subPath yes String A string of type <code>field.subfield.subsubfield</code> pointing to the field to alter payload yes Object The sub item to insert <p>Returns nothing</p>"},{"location":"db-api/#byid_3","title":"byId","text":"<p><code>db.remove.byId(collection, id)</code></p> <p>Removes (delete) a document from a collection</p> Argument Required Type Description collection yes String The collection name id yes Mixed One of the document identifiers (from <code>DROSSE.ids</code>) <p>Returns nothing or <code>false</code> if the document was not found.</p>"},{"location":"dynamic-mocks/","title":"Dynamic mocks (services)","text":"<p>With the services, we cross some sort of line between pure mocking and an actual alternative backend for our frontend app. But sometimes it can be really useful.</p> <p>For example when you want to test interactivity in your app, or you don't have the backend yet because you're on a big project with separated teams and the backend will be implemented after the frontend, but you still have to deliver a working frontend at the same time as the backend, etc.</p> <p>Drosse provides everything you need to implement an interactive mocked backend and let you focus on your frontend usecases.</p> <p>To define a service, you have to do pretty much the same as to define a static mock. Look at this example where we replace the previous \"POST users\" inline mock by a service:</p> routes.json<pre><code>{\n  \"api\": {\n    \"users\": {\n      \"DROSSE\": {\n        \"get\": {\n          \"body\": [\n            { \"id\": 1, \"name\": \"Jorinho\", \"premium\": false },\n            { \"id\": 2, \"name\": \"Tadai\", \"premium\": true }\n          ]\n        },\n        \"post\": {\n          \"service\": true\n        }\n      },\n      \":id\": {\n        \"DROSSE\": {\n          \"get\": {\n            \"static\": true\n          }\n        }\n      }\n    }\n  }\n}\n</code></pre> <p>See? From the <code>routes.json</code> file, it's quite a piece of cake  !</p> <p>Now of course, there is no magic (yet!) here. You have to create a file with the proper name and put it in the <code>services</code> subdirectory of your mocks directory.</p> <p>Info</p> <p>Like for the others subdirectories, you can redefine the <code>services</code> directory name in your <code>.drosserc.js</code> file (see Configuration).</p> <p>To name your file, the rule is even simpler as for the static files. Here you just take in account the non-parameter nodes of your route path. In our case we don't have any parameter node. Our <code>POST /api/users</code> route will resolve into a <code>api.users.post.js</code> service file.</p> <p>Let's just take another example to make it clear. For example for a <code>PUT /api/users/:id/superpowers/:name</code> the service file will be <code>api.users.superpowers.put.js</code>.</p> <p>Now let's have a look inside these service files.</p>"},{"location":"dynamic-mocks/#the-service-file","title":"The service file","text":"<p>A service file must export a function that takes drosse's api object as argument.</p> services/api.users.get.ts<pre><code>import { defineDrosseService } from '@jota-one/drosse'\n\nexport default defineDrosseService(async ({ event, db }) =&gt; {\n  // a lot of cool stuffs...\n})\n</code></pre> <p>As you can see, the object argument gives you access to the well known <code>req</code> and <code>res</code> objects. With those two and the full power of javascript, you can already do more than what you will ever need in a mock-server.</p> <p>Note</p> <p>The return value of your function will be passed to the associated route response (optionally modified by a template).</p> <p>Let's take a full example.</p> <ol> <li>You call <code>POST /api/users</code> and pass this payload: <code>{ name: \"John\" }</code>.</li> <li>The function in the file <code>services/api.users.post.js</code> is executed.</li> <li>Let's say it contains this code:</li> </ol> <pre><code>import { defineDrosseService } from '@jota-one/drosse'\nimport { readBody } from 'h3'\n\nexport default defineDrosseService(async ({ event, db }) =&gt; {\n  const payload = await readBody(event)\n\n  // do whatever you want with your payload\n  return { added: payload.name }\n})\n</code></pre> <ol> <li>Your call returns: <code>{ added: \"John\" }</code>.</li> <li>That's all folks!</li> </ol> <p>Tip</p> <p>But there is more! The <code>db</code> object gives you access to the embedded Drosse database and its super-fancy API. This part requires a full chapter.</p>"},{"location":"getting-started/","title":"Getting started","text":""},{"location":"getting-started/#installation","title":"Installation","text":""},{"location":"getting-started/#as-a-local-npm-dependency-in-your-node-project","title":"As a local npm dependency in your node project","text":"<ol> <li> <p>Simply install it as a dev dependency of the project you want to mock. <pre><code># with npm\nnpm install --save-dev @jota-one/drosse\n\n# or yarn\nyarn add -D @jota-one/drosse\n</code></pre></p> </li> <li> <p>Define a script in your <code>package.json</code> file for simpler usage <pre><code>{\n      \"name\": \"my-node-project\",\n      \"scripts\": {\n        \"mock-server\": \"npx drosse serve path/to/mocks-directory\"\n      },\n      \"devDependencies\": {\n        \"@jota-one/drosse\": \"^1.0.0\"\n      }\n}\n</code></pre></p> </li> </ol> <p>Note</p> <p>Drosse also ships with an esm compatible version (as of version 3.1.0) which you should launch with <code>drosse-esm</code>: <pre><code>{\n      \"name\": \"my-node-project\",\n      \"scripts\": {\n        \"mock-server\": \"npx drosse-esm serve path/to/mocks-directory\"\n      },\n      \"devDependencies\": {\n        \"@jota-one/drosse\": \"^1.0.0\"\n      }\n}\n</code></pre></p>"},{"location":"getting-started/#as-a-global-npm-package","title":"As a global npm package","text":"<ol> <li> <p>Install drosse globally. <pre><code>npm i -g @jota-one/drosse\n</code></pre></p> </li> <li> <p>Run it via the <code>serve</code> command followed by the path of your drosse root folder: <pre><code>drosse serve /path/to/my/mocks\n\n# or with esm mode (as of version 3.1.0)\ndrosse-esm serve /path/to/my/mocks\n</code></pre></p> </li> </ol>"},{"location":"getting-started/#usage","title":"Usage","text":"<p>You need a directory where you will store all your mocks definitions.</p> <ol> <li>Create a directory anywhere in your project repository (or anywhere else).</li> <li>Update the <code>package.json</code> script you just added in the Installation phase to target your new mocks directory.</li> <li>In your mocks directory, create a <code>routes.json</code> file. This file will hold every single mocked route of your server.</li> <li>In the same directory, you can also create a <code>.drosserc.js</code> file. This file allows you to configure your mock server (see Configuration). It's optional but you will very likely need it.</li> </ol>"},{"location":"inline-mocks/","title":"Inline mocks","text":"<p>Let's focus first on the <code>body</code> key, by far the simplest but by far the less cool. If you calm down, you'll be allowed to know about the 2 other solutions. Here's how you can mock your routes with inlined mocks.</p> <pre><code>{\n  \"api\": {\n    \"users\": {\n      \"DROSSE\": {\n        \"get\": {\n          \"body\": [\n            {\"id\": 1, \"name\": \"Jorinho\", \"premium\": false},\n            {\"id\": 2, \"name\": \"Tadai\", \"premium\": true}\n          ]\n        },\n        \"post\": {\n          \"body\": {\"success\": true}\n        }\n      },\n      \":id\": {\n        \"DROSSE\": {\n          \"get\": {\n            \"body\": {\"id\": 1, \"name\": \"Jorinho\", \"premium\": false}\n          }\n        }\n      }\n    }\n  }\n}\n</code></pre> <p>The above JSON is a fully working <code>routes.json</code> file. If you run your mock-server with this file, you will see something like this in your console (amongst other things):</p> <pre><code>4:26:27 PM -&gt; GET     /api/users/:id\n4:26:27 PM -&gt; GET     /api/users\n4:26:27 PM -&gt; POST    /api/users\n\n4:26:27 PM App Example JSON app running at:\n4:26:27 PM  - http://localhost:8000\n</code></pre> <p>Note that the routes are defined in the right order to make sure that a less precise route won't take over a more precise one. Let's create a new route to illustrate this better:</p> <p><pre><code>{\n  \"api\": {\n    \"users\": {\n      \"DROSSE\": {\n        \"get\": {\n          \"body\": [\n            {\"id\": 1, \"name\": \"Jorinho\", \"premium\": false},\n            {\"id\": 2, \"name\": \"Tadai\", \"premium\": true}\n          ]\n        },\n        \"post\": {\n          \"body\": {\"success\": true}\n        }\n      },\n      \":id\": {\n        \"DROSSE\": {\n          \"get\": {\n            \"body\": {\"id\": 1, \"name\": \"Jorinho\", \"premium\": false}\n          }\n        }\n      },\n      \"premiums\": {\n        \"DROSSE\": {\n          \"get\": {\n            \"body\": [{\"id\": 2, \"name\": \"Tadai\"}]\n          }\n        }\n      }\n    }\n  }\n}\n</code></pre> We defined a new route corresponding to this one <code>GET /api/users/premiums</code>. Of course, if Drosse was stupid it would define it in the same order as what we did in the <code>routes.json</code> file, which would make the route unreachable, because it would always be captured by the <code>GET /api/users/:id</code>, passing \"premiums\" as the <code>:id</code> parameter. Let's see what happens if we reload our mock server.</p> <pre><code>4:40:59 PM -&gt; GET     /api/users/premiums\n4:40:59 PM -&gt; GET     /api/users/:id\n4:40:59 PM -&gt; GET     /api/users\n4:40:59 PM -&gt; POST    /api/users\n\n4:40:59 PM App Example JSON app running at:\n4:40:59 PM  - http://localhost:8000\n</code></pre> <p> The <code>/premiums</code> route was declared before the generic <code>/:id</code> route! Conclusion: you don't have to worry about sorting your routes when you define them inside <code>routes.json</code>.</p> <p> That's awesome! It calmed me down totally... I'm ready to know more about the 2 other ways to mock my stuffs!</p>"},{"location":"middlewares/","title":"Middlewares","text":"<p>You can create your own middlewares. Simply create a JS file that exports an h3 event handler like this:</p> <pre><code>export default event =&gt; {\n  // put your middleware code here\n  return { smth: 'cool' }\n}\n</code></pre> <p>Of course you can use <code>async</code> as well in your handler. Refer to the h3 documentation for more details.</p> <p>You can also use \"old\" express-like middlewares (typically if you're using an epxress-based middleware package) using the <code>fromNodeMiddleware</code> utility function from h3:</p> <pre><code>import { fromNodeMiddleware } from 'h3'\n\nexport default fromNodeMiddleware((req, res, next) =&gt; {\n  // put your middleware code here\n  req.setHeader('x-smth', 'cool')\n  next()\n})\n</code></pre>"},{"location":"middlewares/#use-drosse-api-in-your-middleware","title":"Use Drosse API in your middleware","text":"<p>Alternatively you can define your middleware with a supplementary argument, to place at the first position. It will expose the Drosse API inside your middleware, letting you access the <code>db</code> instance for example:</p> <pre><code>import { getRouterParams } from 'h3'\n\nexport default (api, event) =&gt; {\n  // (very) naive role checking :)\n  const { db } = api\n  const user = db.get.byId('users', getRouterParams(req).id)\n  if (user.role !== 'admin') {\n    return { some: 'error' }\n  }\n  return\n}\n</code></pre>"},{"location":"routes/","title":"Routes","text":"<p>Routes are defined in a single <code>json</code> file.</p>"},{"location":"routes/#the-routesjson-file","title":"The routes.json file","text":"<p>This file is mandatory but you can customize its name in the <code>.drosserc.js</code> file (see Configuration). This is where you define all the routes you want to mock. Each route is defined as a tree, with slash as separator.</p> <p> Woot ? Tree ? Slash ? I just want to mock a couple of routes...</p> <p>Ooook, an example worth a thousand sentences of bad explanation. Let's say you want to mock these 2 routes:</p> <pre><code>GET /api/users\nGET /api/users/:id\n</code></pre> <p>You would create a tree in your <code>routes.json</code> file like this:</p> <pre><code>{\n  \"api\": {\n    \"users\": {\n      \":id\": {\n\n      }\n    }\n  }\n}\n</code></pre> <p>That's what we mean by \"a tree\". We consider that an API can be completely described in such a structure.</p> <p> Okay, but where do the actual mocks go ? And if have a GET AND a POST on <code>/api/users</code> ?</p> <p>Good questions, thanks for asking.</p>"},{"location":"routes/#the-drosse-object","title":"The DROSSE object","text":"<p>That's where the <code>DROSSE</code> object comes in and saves our souls. Look at this:</p> <pre><code>{\n  \"api\": {\n    \"users\": {\n      \"DROSSE\": {\n        \"get\": {},\n        \"post\": {}\n      },\n      \":id\": {\n        \"DROSSE\": {\n          \"get\": {}\n        }\n      }\n    }\n  }\n}\n</code></pre> <p>Everything happens inside the <code>DROSSE</code> object. You can insert a <code>DROSSE</code> object anywhere in the tree. A <code>DROSSE</code> object can contain HTTP verbs, like in the above example and a couple of other keys (more on these later).</p> <p> I WANT TO MOCK MY ROUTES!!! WHERE DO I PUT MY MOCKED CONTENTS???</p> <p>There we go! You can mock your datas in 3 different ways:</p> <ol> <li>directly inside the <code>routes.json</code> file, using the <code>body</code> key (see Inline mocks).</li> <li>in a static JSON file with a constrained name (see Static mocks)</li> <li>in a dynamic JS file (we consider it a service) with a constrained name (see Dynamic mocks)</li> </ol> <p>But before we move to the mock contents, let's have a look to the other stuffs you can put into the <code>DROSSE</code> object.</p>"},{"location":"scraping/","title":"Scraping","text":"<p>Do you remember, back in the days, these webscrapers ? You just turn them on then browse a website and they will eventually save the whole website on your machine? Well Drosse provides something similar, but a little less brutal as you can define precisely which endpoint you would like to scrape.</p> <p>Warning</p> <p>Endpoint scraping come along with the Proxy feature. You won't scrape your own defined mocks, right?</p> <p>You can scrape your proxied endpoints either statically or dynamically.</p>"},{"location":"scraping/#static-scraping","title":"Static scraping","text":"<p>The easiest one. Just indicate in your <code>routes.json</code> file, which endpoint you want to scrape.</p> <pre><code>    \"countries\": {\n      \"DROSSE\": {\n        \"proxy\": \"https://restcountries.com/v3.1\"\n      },\n      \"name\": {\n        \"DROSSE\": {\n          \"scraper\": {\n            \"static\": true\n          }\n        }\n      }\n    }\n</code></pre> <p>In the snippet above, we've told Drosse to scrape any call to the <code>.../countries/name/....</code> endpoint.</p> <p>Concretely, it means that Drosse will copy &amp; save the response of any of those calls into a static JSON file in the <code>scraped</code> directory of your <code>mocks</code>.</p> <p>Info</p> <p>As usual, you can redefine this <code>scraped</code> directory name in your <code>.drosserc.js</code> file (see Configuration).</p> <p>This can be a convenient way to populate your mocks contents if the backend API already exists. Just configure your mocks to proxy the existing API and activate the scraper. When you have enought contents, remove the proxy and redefine your mocked routes as <code>static</code> mocks.</p> <p>Ideally you would rework your scraped contents and create relevant <code>static</code> file mocks out of it, maybe add some <code>templates</code>, etc. But you can also let them as they are, in the <code>scraped</code> directory: Drosse will always fallback on this directory if it doesn't find any match in the <code>static</code> directory.</p>"},{"location":"scraping/#dynamic-scraping","title":"Dynamic scraping","text":"<p>The dynamic scraping will let you rework the scraped content and save it exactly how and where you want to.</p> <pre><code>    \"countries\": {\n      \"DROSSE\": {\n        \"proxy\": \"https://restcountries.com/v3.1\"\n      },\n      \"name\": {\n        \"DROSSE\": {\n          \"scraper\": {\n            \"service\": true\n          }\n        }\n      }\n    }\n</code></pre> <p>In contrast with the Static scraping, you simply have to replace the <code>static</code> by <code>service</code>; see above.</p> <p>When Drosse encounter that configuration, it will look for a dedicated scraper service in the <code>scrapers</code> directory. The file must be named accordingly with the scraped endpoint. It's the same logic as for the normal <code>services</code> naming. You take each route node, remove the path parameters and replace <code>/</code> with <code>.</code>. And you ignore the verb.</p> <p>If we take the same example as for the services. For a <code>GET /api/users/:id/superpowers/:name</code> the scraper service file will be <code>api.users.superpowers.js</code>. No parameters, no verb.</p> <p>Info</p> <p>As always, the scrapers directory can be renamed in the <code>.drosserc.js</code> file, with the <code>scraperServicesPath</code> property (see Configuration).</p> <p>Your service must export a function which takes 2 parameters. The first one is the response of your scraped endpoint. It will be a JS object. The second one is the same <code>api</code> object as the one you get in a normal Drosse service.</p> <p>This gives you then access to the <code>db</code> object, the whole drosse <code>config</code> object, the h3 <code>event</code>, etc...</p> <pre><code>import { defineDrosseScraper } from '@jota-one/drosse'\n\nexport default defineDrosseScraper((json, { db, config, req }) {\n  // rework your json\n  // save it in the database\n  // create a proper JSON file in the `collections` directory to have your scraped content automatically reloaded in your DB even if you delete your db file.\n})\n</code></pre>"},{"location":"static-mocks/","title":"Static mocks","text":"<p>As you've probably noticed, the inline mocks are not that dynamic... For instance, if we take the <code>GET /api/users/:id</code> route, you can call it with any value for <code>:id</code>, you will always get the same response. Although it can be enough for most usecases, sometimes we want a little bit more.</p> <p>That's where the so-called static mocks can help you. Where you have only one mock possibility with the inline (<code>body</code>) mock even for parametrized routes, static mocks offer you the possibility to have a different mock for each value of each parameter!</p> <p>That is why these mocks are stored in separated files. It would otherwise bloat your <code>routes.json</code> file.</p> <p>To define a <code>static mock</code>, simply set the <code>static</code> property of your <code>DROSSE</code> object to <code>true</code>. Let's take the previous example and replace the parametrized route inline mock by a static mock:</p> <pre><code>{\n  \"api\": {\n    \"users\": {\n      \"DROSSE\": {\n        \"get\": {\n          \"body\": [\n            {\"id\": 1, \"name\": \"Jorinho\", \"premium\": false},\n            {\"id\": 2, \"name\": \"Tadai\", \"premium\": true}\n          ]\n        },\n        \"post\": {\n          \"body\": {\"success\": true}\n        }\n      },\n      \":id\": {\n        \"DROSSE\": {\n          \"get\": {\n            \"static\": true,\n            \"extensions\": [\"json\"]\n          }\n        }\n      }\n    }\n  }\n}\n</code></pre> <p>With such a definition, when you call <code>GET /api/users/65?withDetails=1</code>, drosse will look for a specific file in the <code>static</code> subdirectory of your mocks directory.</p> <p>Info</p> <p>You can redefine this <code>static</code> directory name in your <code>.drosserc.js</code> file (see Configuration).</p> <p>Drosse will look for different filenames, from the more precise to the more generic until it finds one that matches. Let's keep the above example and see which filenames will be looked for:</p> <pre><code>api.users.65.get&amp;&amp;withDetails=1.json\napi.users.65.get.json\napi.users.65.json\napi.users.{id}.json\n</code></pre> <p>You can pass more than one extension to check for. By default, if you don't pass the <code>extensions</code> key next to the <code>static</code> key, it will fallback to <code>[\"json\"]</code>. If you search for other file types, like images for example, Drosse will automatically return the file instead of a JSON response.</p> <p>If you have a route with several path parameters, drosse will ignore them from left to right. Example, for this route: <pre><code>GET /api/users/:id/posts/:type\n</code></pre></p> <p>Assuming that you have 2 types of posts, <code>unread</code> and <code>read</code> and a big quantity of users, it's more convenient to be able to define a mocked list of <code>read</code> posts and another mocked list of <code>unread</code> posts, independently of the user. For that usecase you can then create only 2 files in your <code>static</code> directory:</p> <pre><code>api.users.{id}.posts.read.get.json\napi.users.{id}.posts.unread.get.json\n</code></pre> <p>Tip</p> <p>If you are not sure of the precedence for a given route, just try and check the drosse console. It will log each failed attempts.</p> <p>If we try to call <code>GET /api/users/3</code> and we have defined the following static mocks files in our <code>static</code> directory.</p> <pre><code>api.users.1.json\napi.users.2.json\napi.users.{id}.json\n</code></pre> <p><pre><code>1:11:29 AM App Example JSON static app running at:\n1:11:29 AM  - http://localhost:8000\n1:11:29 AM  - http://172.22.22.178:8000\n\n1:11:29 AM Mocks root: /some/path/mymocks\n\n1:17:27 AM loadStatic: tried with [/some/path/mymocks/static/api.users.3.get.json]. File not found.\n1:17:27 AM loadStatic: tried with [/some/path/mymocks/static/api.users.3.json]. File not found.\n1:17:27 AM loadStatic: tried with [/some/path/mymocks/static/api.users.{id}.get.json]. File not found.\n</code></pre> You can see above that the system has first tried with the most precise <code>api.users.3.get.json</code> (resolved parameter + verb). Then it tries the same without verb (<code>api.users.3.json</code>). As it still fails, it tries without resolving the parameter, but again with the verb (<code>api.users.{id}.get.json</code>) and finally find a corresponding mock file with <code>api.users.{id}.json</code>. Of course this last one is not logged as it was found.</p> <p>Note</p> <p>If Drosse really doesn't find any file corresponding to the requested endpoint, it will give an ultimate look in the <code>scraped</code> static files. More on this in the Scraping section.</p>"}]}